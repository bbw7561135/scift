!>
!! @brief Test program
!!
program main
	use Math_
	use String_
	use CommandLineParser_
	use AtomicElementsDB_
	use Atom_
	use Molecule_
	use StringIntegerMap_
	implicit none
	
	type(CommandLineParser) :: parser
	type(String) :: iFileName
	logical :: saveFragments
	real(8) :: gamma
	type(Atom) :: atom1
	type(Molecule) :: mol, fragment
	type(StringIntegerMap) :: fragmentsNameMap
	character(3), allocatable :: atomsNameArray(:)
	integer :: i, j
	integer, allocatable :: iComb(:,:)
	integer :: nAtoms
	type(String) :: formula
	class(StringIntegerMapIterator), pointer :: ptr
	integer :: fragmentsCounter
	
	if( command_argument_count() < 2 ) then
		write(*,*) "Usage:"
		write(*,*) "   molecule.fragments -i file.xyz [-s genXYZ]"
		write(*,*) "                                     false   "
		stop
	end if
	
	iFileName = parser.getString( "-i" )
	saveFragments = parser.getLogical( "-s", def=.false. )
	
	call mol.init( iFileName.fstr )
	
	allocate( atomsNameArray(mol.nAtoms()) )
	
	do i=1,mol.nAtoms()
		atomsNameArray(i) = trim(mol.atoms(i).symbol)
	end do
	
	call fragmentsNameMap.init()
	
	fragmentsCounter = 1
	do nAtoms=1,mol.nAtoms()
		
		if( nAtoms == 1 ) then
			write(*,"(A)") trim(FString_fromInteger(nAtoms))//" atom"
		else
			write(*,"(A)") trim(FString_fromInteger(nAtoms))//" atoms"
		end if
		call Math_multisets( mol.nAtoms(), nAtoms, iComb, massNumberConstrain )
		
		do i=1,size(iComb,dim=1)
			call fragment.init( nAtoms, "Generated by molecule.fragments" )
			
			do j=1,nAtoms
				call atom1.init( trim(atomsNameArray( iComb(i,j) )) )
				call fragment.set( j, atom1 )
			end do
			
			formula = trim(fragment.chemicalFormula())
			
			if( .not. fragmentsNameMap.find( formula, ptr ) ) then
				write(*,"(I10,A,A)") fragmentsCounter, ")   ", trim(formula.fstr)
				
				if( saveFragments ) then
					gamma = 0.7_8
					if( fragment.nAtoms() == 2 ) gamma = 2.0_8
					if( fragment.nAtoms() == 3 ) gamma = 1.0_8

					call fragment.randomGeometry( gamma=gamma )
					call fragment.save( trim(formula.fstr)//".xyz" )
				end if
				
				fragmentsCounter = fragmentsCounter + 1
			end if
			
			call fragmentsNameMap.insert( formula, 1 )
		end do
		
		deallocate( iComb )
	end do
	
	deallocate( atomsNameArray )
	
	contains
	
	function massNumberConstrain( multisetPositions, current ) result( output )
		integer, allocatable, intent(in) :: multisetPositions(:)
		integer, intent(in) :: current
		logical :: output
		
		integer :: i, j
		integer :: massNumber
		integer :: composition( AtomicElementsDB_nElems ) !<- [ n1, n2, ..., nN ] n=numberOfAtomsWithZ, pos = atomicNumber
		integer :: pos
		
		massNumber = 0
		composition = 0
		do i=1,current
! 			write(*,*) trim(atomsNameArray( multisetPositions(i) )), AtomicElementsDB_instance.atomicMassNumber( trim(atomsNameArray( multisetPositions(i) )) )
			massNumber = massNumber + AtomicElementsDB_instance.atomicMassNumber( trim(atomsNameArray( multisetPositions(i) )) )
			pos = AtomicElementsDB_instance.atomicNumber( atomsNameArray( multisetPositions(i) ) )
			composition(pos) = composition(pos) + 1
		end do
		
! 		write(*,*) "massNumber = ", massNumber, mol.massNumber()
! 		write(*,"(A,<size(composition)>I2)") "composition    = ", composition
! 		write(*,"(A,<size(composition)>I2)") "compositionMax = ", mol.composition
		
		if( current == size(multisetPositions) ) then
			!----------------------------------------------
			! ¿ El multiset encontrado es correcto ?
			!----------------------------------------------
			output = .false.
			if( all( composition <= mol.composition ) .and. massNumber <= mol.massNumber() ) output = .true.
		else
			!----------------------------------------------
			! ¿ El camino recorrido es incorrecto ?
			!----------------------------------------------
			output = .true.
			if( all( composition <= mol.composition ) .and. massNumber <= mol.massNumber() ) output = .false.
		end if
		
		return
	end function massNumberConstrain

end program main
