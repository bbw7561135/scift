!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!!  This file is part of scift (Scientific Fortran Tools).
!!  Copyright (C) by authors (2013-2014)
!!  
!!  Authors (alphabetic order):
!!    * Aguirre N.F. (nfaguirrec@gmail.com)  (2013-2014)
!!  
!!  Contributors (alphabetic order):
!!  
!!  Redistribution and use in source and binary forms, with or
!!  without modification, are permitted provided that the
!!  following conditions are met:
!!  
!!   * Redistributions of binary or source code must retain
!!     the above copyright notice and this list of conditions
!!     and/or other materials provided with the distribution.
!!   * All advertising materials mentioning features or use of
!!     this software must display the following acknowledgement:
!!     
!!     This product includes software from scift
!!     (Scientific Fortran Tools) project and its contributors.
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module FFT_
	use FFTW3_
	use GOptions_
	use Math_
	use Grid_
	use CNFunction_
	use RNFunction_
	use RandomUtils_
	implicit none
	private
	
	public :: &
		FFT_fftfreqs, &
		FFT_kGridArray, &
		FFT_kGrid, &
		FFT_shift, &
		FFT_ishift, &
		FFT_fft, &
		FFT_ifft, &
		FFT_transformBase, &
		FFT_transform, &
		FFT_iTransform, &
		FFT_spectrum, &
		FFT_spectrumTest, &
		FFT_test
		
        interface FFT_spectrum
            module procedure FFT_spectrumC
            module procedure FFT_spectrumR
        end interface FFT_spectrum
        
        interface FFT_fftfreqs
			module procedure FFT_fftfreqs_Array
        end interface FFT_fftfreqs
        
        interface FFT_shift
	        module procedure FFT_shift_Array
            module procedure FFT_shift_Grid
            module procedure FFT_shift_CNFunction
        end interface FFT_shift
        
        interface FFT_ishift
	        module procedure FFT_ishift_Array
            module procedure FFT_ishift_Grid
!             module procedure FFT_ishift_CNFunction
        end interface FFT_ishift
        
        interface FFT_fft
            module procedure FFT_fft_Array
            module procedure FFT_fft_CNFunction
        end interface FFT_fft
        
        interface FFT_ifft
            module procedure FFT_ifft_Array
!             module procedure FFT_ifft_CNFunction
        end interface FFT_ifft
		
	type, public :: FFT
		logical, private :: persist
		class(CNFunction), pointer, private :: cFunc
		integer(8), private :: plan
		integer, private :: type
		integer, private :: nPoints
		real(8), allocatable :: box(:)
		real(8), allocatable :: kbox(:)
		integer, allocatable :: id(:)
		
		contains
			procedure :: init
			final :: destroy
			procedure :: str
			procedure :: show
			generic :: execute => executePersist!, executeNotPersist
			procedure, private :: executePersist
! 			procedure, private :: executeNotPersist
			procedure :: filter
			procedure :: derivative
	end type FFT
	
	contains
	
	!>
	!! @brief Constructor
	!!
	subroutine init( this, func, type, nPoints, persist )
		class(FFT) :: this 
		class(CNFunction), target, intent(in) :: func
		integer, intent(in), optional :: type
		integer, intent(in), optional :: nPoints
		logical, optional, intent(in) :: persist
		
		logical :: effPersist
		
		if( associated(this.cFunc) ) nullify(this.cFunc)
		this.cFunc => func
		
		this.type = FFT_FORWARD
		if( present(type) ) this.type = type
		
		this.nPoints = this.cFunc.nPoints
		if( present(nPoints) ) this.nPoints = nPoints
		
		this.persist = .false.
		if( present(persist) ) this.persist = persist
		
		if( this.persist ) then
			call dfftw_plan_dft_1d( this.plan, this.nPoints, this.cFunc.yArray, this.cFunc.yArray, FFTW_FORWARD, FFTW_ESTIMATE )
			
			if( allocated(this.box) ) deallocate(this.box)
			allocate( this.box(this.nPoints) )
			this.box = this.cFunc.xGrid.data(1:this.nPoints)
			
			if( allocated(this.id) ) deallocate(this.id)
			allocate( this.id(this.nPoints) )
			
			if( allocated(this.kbox) ) deallocate(this.kbox)
			allocate( this.kbox(this.nPoints) )

			call makeIndicesAndFreqs( this.id, this.kbox, this.nPoints, this.cFunc.xGrid.stepSize )
		end if
	end subroutine init
	
	!>
	!! @brief Destructor
	!!
	subroutine destroy( this )
		type(FFT) :: this
		
		call dfftw_destroy_plan( this.plan )
		
		nullify(this.cFunc)
	end subroutine destroy
	
	!>
	!! @brief
	!!
	function str( this ) result( output )
		class(FFT) :: this 
		character(len=200) :: output
		
		integer :: fmt
		character(len=200) :: strBuffer
		
		output = ""
		
		output = trim(output)//"<FFT:"
		
! 		output = trim(output)//"min="
! 		fmt = int(log10(this.min+1.0))+1
! 		write(strBuffer, "(f<fmt+7>.6)") this.min
! 		output = trim(output)//trim(strBuffer)
! 		
! 		output = trim(output)//",max="
! 		fmt = int(log10(this.max+1.0))+1
! 		write(strBuffer, "(f<fmt+7>.6)") this.max
! 		output = trim(output)//trim(strBuffer)
! 		
! 		output = trim(output)//",h="
! 		fmt = int(log10(this.h+1.0))+1
! 		write(strBuffer, "(f<fmt+7>.6)") this.h
! 		output = trim(output)//trim(strBuffer)
! 		
! 		output = trim(output)//",size="
! 		fmt = int(log10(float(this.size+1)))+1
! 		write(strBuffer, "(i<fmt>)") this.size
! 		output = trim(output)//trim(strBuffer)
		
		output = trim(output)//">"
	end function str
	
	!>
	!! @brief
	!!
	subroutine show( this, unit )
		class(FFT) :: this
		integer, optional, intent(in) :: unit
		
		integer :: effunit
		
		if( present(unit) ) then
			effunit = unit
		else
			effunit = 6
		end if
		
		write(effunit,"(a)") trim(this.str())
	end subroutine show
	
	!>
	!! @brief Organiza los datos para el espectro con frecuencias positivas y negativas
	!!        Rearranges the fft output, moving the zero frequency to the center of the spectrum
	!!        http://www.dsplog.com/2008/08/08/negative-frequency/
	!!
	subroutine makeIndicesAndFreqs( id, freqs, n, h )
		integer, intent(out) :: id(:)
		real(8), intent(out) :: freqs(:)
		integer, intent(in) :: n
		real(8), intent(in) :: h
		
		integer :: i, j
		
		j=1
		do i=n/2+1,n
			id(i) = j
			freqs(i) = 2.0_8*MATH_PI*real(i-1-n/2,8)/n
			j = j+1
		end do
		
		if( Math_isOdd(n) ) then
			j=1
			do i=1,n/2
				id(i) = n/2+1+i
				freqs(i) = 2.0_8*MATH_PI*real(j-1-n/2,8)/n
				j = j+1
			end do
		else
			j=1
			do i=1,n/2
				id(i) = n/2+i
				freqs(i) = 2.0_8*MATH_PI*real(j-1-n/2,8)/n
				j = j+1
			end do
		end if
		
		freqs = freqs/h
	end subroutine makeIndicesAndFreqs
	
	!>
	!! @brief Gets the Fourier spectrum for the function
	!!
	subroutine executePersist( this )
		class(FFT), intent(in) :: this
		
		real(8) :: normConst
		
		!--------------------------------------------------------------
		! La convencion de normalizacion de acuerdo con wikipedia es:
		! Fourier transform non-unitary, angular frequency
		!--------------------------------------------------------------
		if( this.type == FFT_FORWARD ) then
		
			normConst = (this.cFunc.xGrid.max-this.cFunc.xGrid.min)/this.nPoints
			call dfftw_execute( this.plan )
			
			this.cFunc.yArray = abs(this.cFunc.yArray)
! 			do i=1,nPoints
! 				yVecSorted(i) = abs(yVec( this.id(i) ))*normConst
! 			end do
			
		else if( this.type == FFT_BACKWARD ) then
			
			normConst = (this.cFunc.xGrid.max-this.cFunc.xGrid.min)/this.nPoints/(2.0*Math_PI)
			call dfftw_execute( this.plan )
			
			this.cFunc.yArray = abs(this.cFunc.yArray)
! 			do i=1,nPoints
! 				yVecSorted(i) = abs(yVec( this.id(i) ))*normConst
! 			end do
			
		end if
		
		this.cFunc.yArray = this.cFunc.yArray*normConst
	end subroutine executePersist
	
	!>
	!! @brief Gets the Fourier spectrum for the function
	!!
! 	function executeNotPersist( this, type, lastPoint ) result( output )
! 		class(FFT), intent(in) :: this
! 		integer, intent(in), optional :: type
! 		integer, intent(in), optional :: lastPoint
! 		type(RNFunction) :: output
! 		
! 		integer :: effType
! 		
! 		real(8) :: normConst
! 		integer :: nPoints, i
! 		integer(8) :: plan
! 		
! 		real(8), allocatable :: xVec(:)       ! Frecuencias organizadas para el espectro
! 		complex(8), allocatable :: yVec(:)
! 		real(8), allocatable :: yVecSorted(:)   ! Amplitudes organizadas para el espectro
! 		real(8) :: stepSize
! 		integer, allocatable :: id(:)
! 		
! 		effType = FFT_FORWARD
! 		if( present(type) ) effType = type
! 		
! 		nPoints = this.cFunc.nPoints
! 		if( present(lastPoint) ) nPoints = lastPoint
! 		
! 		allocate( id(nPoints) )
! 		allocate( xVec(nPoints) )
! 		allocate( yVec(nPoints) )
! 		allocate( yVecSorted(nPoints) )
! 		
! 		call makeIndicesAndFreqs( id, xVec, nPoints )
! 		xVec = xVec/this.cFunc.xGrid.stepSize
! 		
! 		yVec = this.cFunc.yArray
! 		
! 		if( effType == FFT_FORWARD ) then
! 			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_FORWARD, FFTW_ESTIMATE )
! 		else if( effType == FFT_BACKWARD ) then
! 			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_BACKWARD, FFTW_ESTIMATE )
! 		end if
! 		call dfftw_execute( plan )
! 		call dfftw_destroy_plan( plan )
! 		
! 		!--------------------------------------------------------------
! 		! La convencion de normalizacion de acuerdo con wikipedia es:
! 		! Fourier transform non-unitary, angular frequency
! 		!--------------------------------------------------------------
! 		if( effType == FFT_FORWARD ) then
! 			normConst = (this.cFunc.xGrid.max-this.cFunc.xGrid.min)/nPoints
! 			do i=1,nPoints
! 				yVecSorted(i) = abs(yVec( id(i) ))*normConst
! 			end do
! 		else if( effType == FFT_BACKWARD ) then
! 			normConst = (this.cFunc.xGrid.max-this.cFunc.xGrid.min)/nPoints/(2.0*Math_PI)
! 			do i=1,nPoints
! 				yVecSorted(i) = abs(yVec( id(i) ))*normConst
! 			end do
! 		end if
! 		
! 		call output.fromArrays( xVec, yVecSorted )
! 		
! 		deallocate( id )
! 		deallocate( xVec )
! 		deallocate( yVec )
! 		deallocate( yVecSorted )
! 	end function executeNotPersist

	!>
	!! 
	!!
	subroutine FFTW_driver( rFunc, cFunc, type, lastPoint, yVec, plan, keepPlan )
		class(CNFunction), optional, intent(in) :: rFunc
		class(RNFunction), optional, intent(in) :: cFunc
		integer, optional, intent(in) :: type
		integer, optional, intent(in) :: lastPoint
		complex(8), allocatable :: yVec(:)
		integer(8), optional :: plan
		logical, optional :: keepPlan
		
		integer :: effType
		integer :: nPoints
		logical :: effKeepPlan
		
		effType = FFT_FORWARD
		if( present(type) ) effType = type
		
		if( present(rFunc) ) then
		
			nPoints = rFunc.nPoints
			if( present(lastPoint) ) nPoints = lastPoint
			
			yVec = rFunc.yArray(1:nPoints)
			
		else if( present(cFunc) ) then
			
			nPoints = cFunc.nPoints
			if( present(lastPoint) ) nPoints = lastPoint
				
			yVec = cFunc.yArray(1:nPoints)
				
		end if
		
		effKeepPlan = .false.
		if( present(keepPlan) ) effKeepPlan = keepPlan
			
		if( present(plan) .and. effKeepPlan ) then
			
			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, effType, FFTW_PATIENT )
			call dfftw_execute( plan )
			
		else if( present(plan) .and. .not. effKeepPlan ) then
			
			call dfftw_execute( plan )
			
		else if( .not. present(plan) ) then
			
			! Siempre utilizo la subroutina compleja, porque al parecer
			! la organización de los datos es diferente para los dos casos
			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, effType, FFTW_ESTIMATE )
			call dfftw_execute( plan )
			call dfftw_destroy_plan( plan )
		end if
		
	end subroutine FFTW_driver
	
	!>
	!! @brief Gets the Fourier spectrum for the complex function
	!!
	function FFT_spectrumTest( func, type, lastPoint, paramWindow ) result( output )
		class(CNFunction), intent(in) :: func
		integer, intent(in), optional :: type
		integer, intent(in), optional :: lastPoint
		real(8), intent(in), optional :: paramWindow
		type(RNFunction) :: output
		
		
		
! 		type(CNFunction) :: cOutput
		
! 		cOutput = FFT_transformBase( func, type=type, lastPoint=lastPoint, paramWindow=paramWindow )
! 		call output.fromGridArray( cOutput.xGrid, abs(cOutput.yArray) )
	end function FFT_spectrumTest
	
	!>
	!! 
	!!
! 	subroutine applyWindow( func, type, lastPoint, fftShift, paramWindow )
! 		class(CNFunction), intent(in) :: func
! 		integer, optional, intent(in) :: type
! 		integer, optional, intent(in) :: lastPoint
! 		logical, optional, intent(in) :: fftShift
! 		real(8), optional, intent(in) :: paramWindow
! 		type(CNFunction) :: output
! 		
! 		integer :: effType
! 		integer :: nPoints
! 		logical :: effFftShift
! 		
! 		real(8) :: normConst
! 		integer :: i
! 		integer(8) :: plan
! 		
! 		real(8), allocatable :: xVec(:)       ! Frecuencias organizadas para el espectro
! 		complex(8), allocatable :: yVec(:)
! 		complex(8), allocatable :: yVecSorted(:)   ! Amplitudes organizadas para el espectro
! 		integer, allocatable :: id(:)
! 		
! 		real(8) :: t0, w, dw, range
! 		
! 		effType = FFT_FORWARD
! 		if( present(type) ) effType = type
! 		
! 		nPoints = func.nPoints
! 		if( present(lastPoint) ) nPoints = lastPoint
! 		
! 		effFftShift = .true.
! 		if( present(fftShift) ) effFftShift = fftShift
! 		
! 		allocate( id(nPoints) )
! 		allocate( xVec(nPoints) )
! 		allocate( yVec(nPoints) )
! 		
! 		call makeIndicesAndFreqs( id, xVec, nPoints )
! 
! 		if( present(paramWindow) ) then
! 			range = abs( func.xGrid.at(nPoints)-func.xGrid.at(1) )
! 			t0 = func.xGrid.at(1) + range/2.0_8
! 			w = (1.0_8-2.0_8*paramWindow)*range
! 			dw = paramWindow*range
! 			
! 			do i=1,nPoints
! 				yVec(i) = func.yArray(i)*Math_erfTophat( func.xGrid.at(i), t0, w, dw )
! ! 				yVec(i) = func.yArray(i)*cos( Math_PI*( func.xGrid.at(i) - t0 )/2.0_8/range )**2
! 			end do
! 		else
! 			yVec = func.yArray(1:nPoints)
! 		end if
! 		
! 		if( effType == FFT_FORWARD ) then
! 			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_FORWARD, FFTW_ESTIMATE )
! 		else if( effType == FFT_BACKWARD ) then
! 			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_BACKWARD, FFTW_ESTIMATE )
! 		end if
! 		call dfftw_execute( plan )
! 		call dfftw_destroy_plan( plan )
! 		
! 		
! 		deallocate( id )
! 		deallocate( xVec )
! 		deallocate( yVec )
! 	end subroutine applyWindow
	
	!>
	!! @brief Gets the Fourier spectrum for the function
	!!
	!! @paramWindow percentage window width [0.0,0.5]
	!!
	function FFT_transformBase( func, type, lastPoint, centeredWindow, typeWindow, paramWindow, oFileWindow ) result( output )
		class(CNFunction), intent(in) :: func
		integer, optional, intent(in) :: type
		integer, optional, intent(in) :: lastPoint
		logical, optional, intent(in) :: centeredWindow
		integer, optional, intent(in) :: typeWindow
		real(8), optional, intent(in) :: paramWindow
		character(*), optional, intent(in) :: oFileWindow  !< @todo Por alguna razon no funciona si pongo character(100) por ejemplo
		type(CNFunction) :: output
		
		integer :: effType
		integer :: nPoints
		
		logical :: effCenteredWindow
		integer :: effTypeWindow
		real(8) :: effParamWindow
		
		real(8) :: normConst
		integer :: i
		integer(8) :: plan
		
		real(8), allocatable :: xVec(:)       ! Frecuencias organizadas para el espectro
		complex(8), allocatable :: yVec(:)
		complex(8), allocatable :: yVecSorted(:)   ! Amplitudes organizadas para el espectro
		integer, allocatable :: id(:)
		
		real(8) :: t0, w, dw, range, window
		
		effType = FFT_FORWARD
		if( present(type) ) effType = type
		
		nPoints = func.nPoints
		if( present(lastPoint) ) nPoints = lastPoint
		
		effCenteredWindow = .false.
		if( present(centeredWindow) ) effCenteredWindow = centeredWindow
		
		effTypeWindow = FFT_WINDOW_NONE
		if( present(typeWindow) ) effTypeWindow = typeWindow
		
		select case( effTypeWindow )
			case( FFT_WINDOW_COS )
				effParamWindow = 2.0_8
			case( FFT_WINDOW_GAUSS )
				effParamWindow = 4.0_8
			case( FFT_WINDOW_ERF_TOPHAT )
				effParamWindow = 0.2_8
			case ( FFT_WINDOW_NONE )
				effParamWindow = -1.0_8
		end select
		if( present(paramWindow) ) effParamWindow = paramWindow
		
		if( present(oFileWindow) ) open( unit=32, file=trim(oFileWindow), status="unknown" )
		
		allocate( id(nPoints) )
		allocate( xVec(nPoints) )
		allocate( yVec(nPoints) )
		
! 		call makeIndicesAndFreqs( id, xVec, nPoints, func.xGrid.stepSize )
		call FFT_kGridArray( xVec, nPoints, func.xGrid.stepSize )
		
		if( effCenteredWindow ) then
			range = abs( func.xGrid.at(nPoints)-func.xGrid.at(1) )/2.0_8
			t0 = func.xGrid.at(1) + range
		else
			range = abs( func.xGrid.at(nPoints)-func.xGrid.at(1) )
			t0 = func.xGrid.at(1)
		end if
		
		select case( effTypeWindow )
			case( FFT_WINDOW_COS )
				
				do i=1,nPoints
					window = cos( Math_PI*( func.xGrid.at(i) - t0 )/2.0_8/range )**paramWindow
					yVec(i) = func.yArray(i)*window
					
					if( present(oFileWindow) ) write(32,*) func.xGrid.at(i), window
				end do
				
			case( FFT_WINDOW_GAUSS )
				
				do i=1,nPoints
! 					window = paramWindow*exp(-0.5_8*paramWindow**2*(func.xGrid.at(i)-t0)**2/range**2)/range/sqrt(2.0*Math_PI)
					window = exp(-0.5_8*paramWindow**2*(func.xGrid.at(i)-t0)**2/range**2)
					yVec(i) = func.yArray(i)*window
					
					if( present(oFileWindow) ) write(32,*) func.xGrid.at(i), window
				end do
				
			case( FFT_WINDOW_ERF_TOPHAT )
				
				if( effCenteredWindow ) then
					w = 2.0_8*(1.0_8-2.0_8*paramWindow)*range
				else
					w = 2.0_8*(1.0_8-paramWindow)*range
				end if

				dw = paramWindow*range
				
				do i=1,nPoints
					window = Math_erfTophat( func.xGrid.at(i), t0, w, dw )
					yVec(i) = func.yArray(i)
					
					if( present(oFileWindow) ) write(32,*) func.xGrid.at(i), window
				end do
			
			case ( FFT_WINDOW_NONE )
				
				yVec = func.yArray(1:nPoints)
				
				if( present(oFileWindow) ) then
					do i=1,nPoints
						window = 1.0_8
						
						if( present(oFileWindow) ) write(32,*) func.xGrid.at(i), window
					end do
				end if
		end select
		
		if( present(oFileWindow) ) close(32)
		
		if( effType == FFT_FORWARD ) then
			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_FORWARD, FFTW_ESTIMATE )
		else if( effType == FFT_BACKWARD ) then
			call dfftw_plan_dft_1d( plan, nPoints, yVec, yVec, FFTW_BACKWARD, FFTW_ESTIMATE )
		end if
		call dfftw_execute( plan )
		call dfftw_destroy_plan( plan )
		
		!--------------------------------------------------------------
		! La convencion de normalizacion de acuerdo con wikipedia es:
		! Fourier transform non-unitary, angular frequency
		!--------------------------------------------------------------
		if( effType == FFT_FORWARD ) then
			
			normConst = (func.xGrid.at(nPoints)-func.xGrid.at(1))/nPoints
			call output.fromArrays( xVec(1:nPoints), yVec(1:nPoints)*normConst )
			
		else if( effType == FFT_BACKWARD ) then
			
			normConst = (func.xGrid.at(nPoints)-func.xGrid.at(1))/nPoints/(2.0*Math_PI)
			call output.fromArrays( xVec(1:nPoints), yVec(1:nPoints)*normConst )
			
		end if
		
		deallocate( id )
		deallocate( xVec )
		deallocate( yVec )
	end function FFT_transformBase
	
	!>
	!! @brief Gets the Fourier spectrum for the complex function
	!!
	function FFT_spectrumC( func, type, lastPoint, centeredWindow, typeWindow, paramWindow, oFileWindow, component ) result( output )
		class(CNFunction), intent(in) :: func
		integer, optional, intent(in) :: type
		integer, optional, intent(in) :: lastPoint
		logical, optional, intent(in) :: centeredWindow
		integer, optional, intent(in) :: typeWindow
		real(8), optional, intent(in) :: paramWindow
		character(100), optional, intent(in) :: oFileWindow
		integer, optional, intent(in) :: component
		type(RNFunction) :: output
		
		integer :: effComponent
		type(CNFunction) :: cOutput
		
		effComponent = 0
		if( present(component) ) effComponent = component
		
		cOutput = FFT_transformBase( func, type, lastPoint, centeredWindow, typeWindow, paramWindow, oFileWindow )
! 		call FFT_shift( cOutput )
		
		select case( effComponent )
			case( 0 )
				call output.fromGridArray( cOutput.xGrid, abs(cOutput.yArray) )
			case( 1 )
				call output.fromGridArray( cOutput.xGrid, real(cOutput.yArray) )
			case( 2 )
				call output.fromGridArray( cOutput.xGrid, aimag(cOutput.yArray) )
		end select
	end function FFT_spectrumC
	
	!>
	!! @brief Gets the Fourier spectrum for the real funtion
	!!
	function FFT_spectrumR( func, type, lastPoint, centeredWindow, typeWindow, paramWindow, oFileWindow ) result( output )
		class(RNFunction), intent(in) :: func
		integer, optional, intent(in) :: type
		integer, optional, intent(in) :: lastPoint
		logical, optional, intent(in) :: centeredWindow
		integer, optional, intent(in) :: typeWindow
		real(8), optional, intent(in) :: paramWindow
		character(100), optional, intent(in) :: oFileWindow
		type(RNFunction) :: output
		
		type(CNFunction) :: cOutput
		
! 		cOutput = FFT_transformBase( func, func, type, lastPoint, centeredWindow, typeWindow, paramWindow, oFileWindow )
! 		call output.fromGridArray( cOutput.xGrid, abs(cOutput.yArray) )
	end function FFT_spectrumR
	
	!>
	!! @brief Gets the Fourier transform for the function
	!!
	function filter( this, kindOfFilter, cutoff ) result( output )
		class(FFT), intent(in) :: this
		integer, intent(in), optional :: kindOfFilter
		real(8), intent(in), optional :: cutoff
		type(CNFunction) :: output
		
		integer :: effKindOfFilter
		real(8) :: effCutoff
		
		integer :: nPoints, i
		
		real(8), allocatable :: xVec(:)
		complex(8), allocatable :: yVec(:)
		real(8), allocatable :: yVecSorted(:)
		real(8) :: stepSize
		integer, allocatable :: id(:)
		
		integer(8) :: FFT_plan
		
		effKindOfFilter = FFT_FILTER_NONE
		if( present(kindOfFilter) ) effKindOfFilter = kindOfFilter
		
		effCutoff = 0.0_8
		if( present(cutoff) ) effCutoff = cutoff
		
		nPoints = this.cFunc.nPoints
		
		allocate( id(nPoints) )
		allocate( xVec(nPoints) )
		allocate( yVec(nPoints) )
		allocate( yVecSorted(nPoints) )
		
		!-----------------------------------------------
		! Se construye el grid en el espacio recíproco
		! @todo Puede que dependa del número de puntos
		!-----------------------------------------------
		do i=1,nPoints/2+1
			xVec(i) = 2.0_8*MATH_PI*real(i-1,8)/this.cFunc.xGrid.stepSize/real(nPoints,8)
		end do
		do i=nPoints/2+2,nPoints
			xVec(i)=-xVec(nPoints+2-i)
		end do
		
		yVec = this.cFunc.yArray
		
		call dfftw_plan_dft_1d( FFT_plan, nPoints, yVec, yVec, FFTW_FORWARD, FFTW_ESTIMATE )
		call dfftw_execute( FFT_plan )
		call dfftw_destroy_plan( FFT_plan )
		
		if( effKindOfFilter /= FFT_FILTER_NONE ) then
		
			select case( effKindOfFilter )
				case( FFT_FILTER_AMPLITUDE )
				
					do i=1,nPoints
						if( abs(yVec(i)) < effCutoff ) then
							yVec(i) = 0.0_8
						end if
					end do
					
				case( FFT_FILTER_AMPLITUDE_FRACTION )
				
					do i=1,nPoints
						if( abs(yVec(i)) < effCutoff*maxval(abs(yVec)) ) then
							yVec(i) = 0.0_8
						end if
					end do
					
				case( FFT_FILTER_FREQUENCY )
				
					do i=1,nPoints
						if( abs(xVec(i)) > effCutoff ) then
							yVec(i) = 0.0_8
						end if
					end do
					
			end select
			
		end if
		
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Gets the inverse Fourier transform
		call dfftw_plan_dft_1d( FFT_plan, nPoints, yVec, yVec, FFTW_BACKWARD, FFTW_ESTIMATE )
		call dfftw_execute( FFT_plan )
		call dfftw_destroy_plan( FFT_plan )
		
		call output.init( this.cFunc.xGrid, yVec/nPoints )
		
		deallocate( id )
		deallocate( xVec )
		deallocate( yVec )
		deallocate( yVecSorted )
	end function filter
	
	!>
	!! @brief Gets the derivative by using FFT
	!!
	function derivative( this, order, kindOfFilter, cutoff ) result( output )
		class(FFT), intent(in) :: this
		integer, intent(in) :: order
		integer, intent(in), optional :: kindOfFilter
		real(8), intent(in), optional :: cutoff
		type(CNFunction) :: output
		
		integer :: effKindOfFilter
		real(8) :: effCutoff
		
		integer :: nPoints, i
		
		real(8), allocatable :: xVec(:)
		complex(8), allocatable :: yVec(:)
		real(8), allocatable :: yVecSorted(:)
		real(8) :: stepSize
		integer, allocatable :: id(:)
		
		integer(8) :: FFT_plan
		
		effKindOfFilter = FFT_FILTER_NONE
		if( present(kindOfFilter) ) effKindOfFilter = kindOfFilter
		
		effCutoff = 0.0_8
		if( present(cutoff) ) effCutoff = cutoff
		
		nPoints = this.cFunc.nPoints
		
		allocate( id(nPoints) )
		allocate( xVec(nPoints) )
		allocate( yVec(nPoints) )
		allocate( yVecSorted(nPoints) )
		
! ! 		!-----------------------------------------------
! ! 		! Se construye el grid en el espacio recíproco
! ! 		! @todo Puede que dependa del número de puntos
! ! 		!-----------------------------------------------
! ! 		do i=1,nPoints/2+1
! ! 			xVec(i) = 2.0_8*MATH_PI*real(i-1,8)/this.cFunc.xGrid.stepSize/real(nPoints,8)
! ! 		end do
! ! 		do i=nPoints/2+2,nPoints
! ! 			xVec(i)=-xVec(nPoints+2-i)
! ! 		end do
		
		yVec = this.cFunc.yArray
		
		call dfftw_plan_dft_1d( FFT_plan, nPoints, yVec, yVec, FFTW_FORWARD, FFTW_ESTIMATE )
		call dfftw_execute( FFT_plan )
		call dfftw_destroy_plan( FFT_plan )
		
		if( effKindOfFilter /= FFT_FILTER_NONE ) then
		
			select case( effKindOfFilter )
				case( FFT_FILTER_AMPLITUDE )
				
					do i=1,nPoints
						if( abs(yVec(i)) < effCutoff ) then
							yVec(i) = 0.0_8
						end if
					end do
					
				case( FFT_FILTER_AMPLITUDE_FRACTION )
				
					do i=1,nPoints
						if( abs(yVec(i)) < effCutoff*maxval(abs(yVec)) ) then
							yVec(i) = 0.0_8
						end if
					end do
					
				case( FFT_FILTER_FREQUENCY )
				
					do i=1,nPoints
						if( abs(xVec(i)) > effCutoff ) then
							yVec(i) = 0.0_8
						end if
					end do
					
			end select
			
		end if
		
! 		yVec = (2.0_8*Math_PI*Math_I*xVec)**order*yVec  ! Esto es si X no lleva el 2pi
		yVec = (Math_I*xVec)**order*yVec
		
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Gets the inverse Fourier transform
		call dfftw_plan_dft_1d( FFT_plan, nPoints, yVec, yVec, FFTW_BACKWARD, FFTW_ESTIMATE )
		call dfftw_execute( FFT_plan )
		call dfftw_destroy_plan( FFT_plan )
		
		call output.init( this.cFunc.xGrid, yVec/nPoints )
		
		deallocate( id )
		deallocate( xVec )
		deallocate( yVec )
		deallocate( yVecSorted )
	end function derivative
	
	!>
	!! @brief Return the Discrete Fourier Transform sample frequencies. ( see: numpy.fft.fftfreq )
	!! 
	!! The returned float array f contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start).
	!! For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.
	!! 
	!! Given a window length n and a sample spacing d:
	!! 
	!! f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even
	!! f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd
	!!
	!! @param n : int. Window length.
	!! @param d : scalar, optional. Sample spacing (inverse of the sampling rate). Defaults to 1.
	!! @returns:	f : ndarray. Array of length n containing the sample frequencies.
	!!
	subroutine FFT_fftfreqs_Array( array, d )
		real(8) :: array(:)
		real(8), optional, intent(in) :: d
		
		real(8) :: effD
		
		integer :: i, n
		
		effD = 1.0_8
		if( present(d) ) effD = d
		
		n = size( array )
		
		array(1) = 0.0_8
		do i=2,floor(n/2.0_8)+1
			array(i)     =  real(i-1,8)/effD/real(n,8)
			array(n-i+2) = -real(i-1,8)/effD/real(n,8)
		end do
	end subroutine FFT_fftfreqs_Array
	
	!>
	!! @brief
	!!
	subroutine FFT_kGridArray( kArray, n, h )
		real(8), allocatable :: kArray(:)
		integer, intent(in) :: n
		real(8), intent(in) :: h
		
		integer :: i
		
		kArray(1) = 0.0_8
		
		do i=2,floor(n/2.0_8)+1
			kArray(i)     =  2.0_8*MATH_PI*real(i-1,8)/h/real(n,8)
			kArray(n-i+2) = -2.0_8*MATH_PI*real(i-1,8)/h/real(n,8)
		end do
	end subroutine FFT_kGridArray
	
	!>
	!! @brief
	!!
	function FFT_kGrid( xGrid ) result( kGrid )
		type(Grid), intent(in) :: xGrid
		type(Grid) :: kGrid
		
		integer :: i, j, k
		integer :: n
		real(8) :: h
		
		real(8), allocatable :: kArray(:)
		
		n = xGrid.nPoints
		h = xGrid.stepSize
				
		!-------------------------------------
		! Codigo de Sergio
		! @todo probablemente no se cumpla
		!       para numero impar de puntos
		!-------------------------------------
! 		do i=1,n/2+1
! 			kArray(i) = 2.0_8*MATH_PI*real(i-1,8)/h/real(n,8)
! 		end do
! 		do i=n/2+2,n
! 			kArray(i)=-kArray(n+2-i)
! 		end do

		!-------------------------------------
		! Otro codigo que no se de donde saque
		!-------------------------------------
! 		allocate( kArray(n) )
! 		
! 		do i=1,n/2+1
! 			kArray(i) = 2.0_8*MATH_PI*real(i-1,8)/h/real(n,8)
! 		end do
! 		do i=n/2+2,n
! 			kArray(i)=-kArray(n+2-i)
! 		end do
! 		
! 		call kGrid.init( kArray )

! -----------------------

! 		allocate( kArray(n) )
! 		
! 		do i=1,floor(n/2.0_8)+1
! 			kArray(i) = 2.0_8*MATH_PI*real(i-1,8)/h/real(n,8)
! 		end do
! 		
! 		j=floor(n/2.0_8)+2
! 		do i=floor((n+1)/2.0_8),2,-1
! 			kArray(j)=-kArray(i)
! 		end do
! 		
! 		call kGrid.init( kArray )

!-----------------------------------------
		if( .not. allocated(kArray) ) allocate( kArray(n) )
		
		call FFT_kGridArray( kArray, n, h )
		
		call kGrid.init( kArray )
		
		deallocate( kArray )

! --------------------------------
! 		allocate( kArray(n) )
! 		
! 		j=1
! 		do i=n/2+1,n
! 			kArray(i) = 2.0_8*MATH_PI*real(i-1-n/2,8)/n
! 			j = j+1
! 		end do
! 		
! 		if( Math_isOdd(n) ) then
! 			j=1
! 			do i=1,n/2
! 				kArray(i) = 2.0_8*MATH_PI*real(j-1-n/2,8)/n
! 				j = j+1
! 			end do
! 		else
! 			j=1
! 			do i=1,n/2
! 				kArray(i) = 2.0_8*MATH_PI*real(j-1-n/2,8)/n
! 				j = j+1
! 			end do
! 		end if
! 		
! 		kArray = kArray/h
! 		call kGrid.init( kArray )
! --------------------------------
		
		deallocate( kArray )
	end function FFT_kGrid
	
	!>
	!! @brief Shift the zero-frequency component to the center of the spectrum
	!! @see http://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fftshift.html#numpy.fft.fftshift
	!! 
	!! This function swaps half-spaces for all axes listed (defaults to all). Note that y[0] is the Nyquist component only if len(x) is even.
	!! 
	!! iArray : array_like. Input array.
	!! oArray : array_like. Output array (optional). The shifted array.
	!!
	subroutine FFT_shift_Array( iArray, oArray )
		real(8) :: iArray(:)
		real(8), optional :: oArray(:)
		
		real(8), allocatable :: tmpArray(:)
		integer :: i, j, n, p0
		integer, allocatable :: pos(:)
		
		n = size( iArray )
		p0 = Math_floorDivision( n+1, 2 )+1
		
		allocate( pos(n) )
		
		i = 1
		do j=p0,n
			pos(i) = j
			i = i+1
		end do
		
		do j=1,p0-1
			pos(i) = j
			i = i+1
		end do
		
		if( present(oArray) ) then
			oArray = iArray
			
			do i=1,n
				oArray( i ) = iArray( pos(i) )
			end do
		else
			allocate( tmpArray(n) )
			tmpArray = iArray
			
			do i=1,n
				iArray( i ) = tmpArray( pos(i) )
			end do
			
			deallocate( tmpArray )
		end if
		
		deallocate( pos )
	end subroutine FFT_shift_Array
	
	!>
	!! @brief The inverse of FFT_shift. Although identical for even-length x, the functions differ by one sample for odd-length x.
	!! 
	!! @parameter iArray : array_like. Input array.
	!! @parameter oArray : array_like. Output array (optional). The shifted array.
	!!
	subroutine FFT_ishift_Array( iArray, oArray )
		real(8) :: iArray(:)
		real(8), optional :: oArray(:)
		
		real(8), allocatable :: tmpArray(:)
		integer :: i, j, n, p2
		integer, allocatable :: pos(:)
		
		n = size( iArray )
		p2 = n-Math_floorDivision( n+1, 2 )+1
		
		allocate( pos(n) )
		
		i = 1
		do j=p2,n
			pos(i) = j
			i = i+1
		end do
		
		do j=1,p2-1
			pos(i) = j
			i = i+1
		end do
		
		if( present(oArray) ) then
			oArray = iArray
			
			do i=1,n
				oArray( i ) = iArray( pos(i) )
			end do
		else
			allocate( tmpArray(n) )
			tmpArray = iArray
			
			do i=1,n
				iArray( i ) = tmpArray( pos(i) )
			end do
			
			deallocate( tmpArray )
		end if
		
		deallocate( pos )
	end subroutine FFT_ishift_Array
	
	!>
	!! @brief
	!!
	subroutine FFT_shift_Grid( iGrid, oGrid )
		class(Grid) :: iGrid
		class(Grid), optional :: oGrid
		
		if( iGrid.isEquallyspaced ) then
			call GOptions_warning( &
				"Grid should not be equally spaced", &
				"FFT_shift_Grid()" &
			)
		end if
		
		if( present(oGrid) ) then
			oGrid = iGrid
			
			call FFT_shift_Array( oGrid.data )
			call oGrid.checkEquallyspaced()
		else
			call FFT_shift_Array( iGrid.data )
			call iGrid.checkEquallyspaced()
		end if
		
	end subroutine FFT_shift_Grid
	
	!>
	!! @brief
	!!
	subroutine FFT_ishift_Grid( iGrid, oGrid )
		class(Grid) :: iGrid
		class(Grid), optional :: oGrid
		
		if( .not. iGrid.isEquallyspaced ) then
			call GOptions_warning( &
				"Grid should be equally spaced", &
				"FFT_ishift_Grid()" &
			)
		end if
		
		if( present(oGrid) ) then
			oGrid = iGrid
			
			call FFT_ishift_Array( oGrid.data )
			call oGrid.checkEquallyspaced()
		else
			call FFT_ishift_Array( iGrid.data )
			call iGrid.checkEquallyspaced()
		end if
		
	end subroutine FFT_ishift_Grid
	
	!>
	!! @brief
	!!
	subroutine FFT_shift_CNFunction( iFunc, oFunc )
		class(CNFunction) :: iFunc
		class(CNFunction), optional :: oFunc
		
		type(CNFunction) :: tmpFunc
		type(Grid) :: tmpGrid
		integer :: i, j, n, p0
		integer, allocatable :: pos(:)
		
		if( iFunc.isEquallyspaced() ) then
			call GOptions_warning( &
				"Grid should not be equally spaced", &
				"FFT_shift_Grid()" &
			)
		end if
		
		n = iFunc.nPoints
		p0 = Math_floorDivision( n+1, 2 )+1
		
		allocate( pos(n) )
		
		i = 1
		do j=p0,n
			pos(i) = j
			i = i+1
		end do
		
		do j=1,p0-1
			pos(i) = j
			i = i+1
		end do
		
		if( present(oFunc) ) then
			call oFunc.init( iFunc.xGrid )
			tmpGrid = iFunc.xGrid
			
			do i=1,n
				call oFunc.set( i, iFunc.at( pos(i) ) )
				call oFunc.xGrid.set( i, tmpGrid.at( pos(i) ) )
			end do
			
			call oFunc.checkEquallyspaced()
		else
			tmpFunc = iFunc
			tmpGrid = iFunc.xGrid
			
			do i=1,n
				call iFunc.set( i, tmpFunc.at( pos(i) ) )
				call iFunc.xGrid.set( i, tmpGrid.at( pos(i) ) )
			end do
			
			call iFunc.checkEquallyspaced()
		end if
		
		deallocate( pos )
	end subroutine FFT_shift_CNFunction
	
	!>
	!! 
	!!
	subroutine FFT_fft_Array( iArray, oArray, plan )
		complex(8) :: iArray(:)
		complex(8), optional :: oArray(:)
		integer(8), optional :: plan
		
		integer(8) :: internalPlan
		
		if( present(oArray) ) then
			if( size(iArray) /= size(oArray) ) &
				call GOptions_error( "iArray and oArray have not the same size", "FFT_fft_Array" )
			
			if( present(plan) ) then
				call dfftw_execute( plan )
			else
				call dfftw_plan_dft_1d( internalPlan, size(iArray), iArray, oArray, FFT_FORWARD, FFTW_ESTIMATE )
				call dfftw_execute( internalPlan )
				call dfftw_destroy_plan( internalPlan )
			end if
		else
			if( present(plan) ) then
				call dfftw_execute( plan )
			else
		write(*,*) "Hola2", iArray(1:10)
				call dfftw_plan_dft_1d( internalPlan, size(iArray), iArray, iArray, FFT_FORWARD, FFTW_ESTIMATE )
		write(*,*) "Entonces"
				call dfftw_execute( internalPlan )
		write(*,*) "Entonces2"
				call dfftw_destroy_plan( internalPlan )
		write(*,*) "Entonces3"
			end if
		end if
		write(*,*) "Entonces4"
	end subroutine FFT_fft_Array
	
	!>
	!! 
	!!
	subroutine FFT_ifft_Array( iArray, oArray )
		complex(8) :: iArray(:)
		complex(8), optional :: oArray(:)
		
		integer(8) :: plan
		
		if( present(oArray) ) then
			if( size(iArray) /= size(oArray) ) &
				call GOptions_error( "iArray and oArray have not the same size", "FFT_ifft_Array" )
			
			call dfftw_plan_dft_1d( plan, size(iArray), iArray, oArray, FFT_BACKWARD, FFTW_ESTIMATE )
			call dfftw_execute( plan )
			call dfftw_destroy_plan( plan )
			
			oArray = oArray/size(oArray)
		else
			call dfftw_plan_dft_1d( plan, size(iArray), iArray, iArray, FFT_BACKWARD, FFTW_ESTIMATE )
			call dfftw_execute( plan )
			call dfftw_destroy_plan( plan )
			
			iArray = iArray/size(iArray)
		end if
	end subroutine FFT_ifft_Array
	
	!>
	!! 
	!!
	subroutine FFT_fft_CNFunction( iFunc, oFunc, plan )
		type(CNFunction) :: iFunc
		type(CNFunction), optional :: oFunc
		integer(8), optional :: plan
		
		real(8) :: dx
		
		! @todo Check for checkEquallyspaced
		dx = iFunc.xGrid.stepSize
		
! 		if( present(oFunc) ) oFunc = iFunc
		
! 		call FFT_fft( iFunc.yArray, oFunc.yArray, plan )
		call iFunc.show()
		call FFT_fft_Array( iFunc.yArray )
		write(*,*) "FIn1"
		call FFT_fftfreqs_Array( oFunc.xGrid.data, dx )
		write(*,*) "FIn2"
	end subroutine FFT_fft_CNFunction
	
	!>
	!! @brief Gets the Fourier transform of the funtion func
	!!
	function FFT_transform( func, lastPoint, fftShift, paramWindow ) result( output )
		type(CNFunction), intent(in) :: func
		integer, intent(in), optional :: lastPoint
		logical, intent(in), optional :: fftShift
		real(8), intent(in), optional :: paramWindow
		type(CNFunction) :: output
		
		logical :: effFftShift
		
		effFftShift = .false.
		if( present(fftShift) ) effFftShift = fftShift
		
		output = FFT_transformBase( func, type=FFT_FORWARD, lastPoint=lastPoint, paramWindow=paramWindow )
		
		if( effFftShift ) call FFT_shift( output )
	end function FFT_transform
	
	!>
	!! @brief Gets the Fourier transform of the funtion func
	!!
	function FFT_iTransform( func, lastPoint, fftShift, paramWindow ) result( output )
		type(CNFunction), intent(in) :: func
		integer, intent(in), optional :: lastPoint
		logical, intent(in), optional :: fftShift
		real(8), intent(in), optional :: paramWindow
		type(CNFunction) :: output
		
		logical :: effFftShift
		
		effFftShift = .false.
		if( present(fftShift) ) effFftShift = fftShift
		
		output = FFT_transformBase( func, type=FFT_BACKWARD, lastPoint=lastPoint, paramWindow=paramWindow )
		
		if( effFftShift ) call FFT_shift( output )
	end function FFT_iTransform
	
	!>
	!! This is neccesary only for FFT_test()
	!!       f = exp(-0.44*x)*sin(x)**2
	!!   df/dx = exp(-0.44*x)*(2.0*sin(x)*cos(x)-0.44*sin(x)**2)
	!! d2f/dx2 = exp(-0.44*x)*(2.0*cos(x)**2 - 1.76*cos(x)*sin(x) - 2.0*sin(x)**2 + 0.1936*sin(x)**2)
	!!
	function funcTest( x ) result( output )
		real(8), intent(in) :: x
		complex(8) :: output
		
! 		output = 1.0_8*sin(1.0_8*x) &  !  1 rad/sec component
! 				+0.6_8*sin(3.0_8*x) &  !  3 rad/sec component
! 				+0.4_8*sin(5.0_8*x) &  !  5 rad/sec component
! 				+0.2_8*sin(RandomUtils_uniform([7.0_8,10.0_8])*x)  !  uniform noise

		output = cos(x**2)

! 		output = exp(-0.44*x)*sin(x)**2.0 + 0.001*sin(30.0*x)  ! noise 30 rad/sec
		
! 		output = 0.5_8*cos(5.0_8*x) - 0.5_8*Math_I*sin(5.0_8*x) + 2.0_8*sin(2.5_8*x)
	end function funcTest
	
	!>
	!! This is neccesary only for FFT_test()
	!!       f = exp(-0.44*x)*sin(x)**2
	!!   df/dx = exp(-0.44*x)*(2.0*sin(x)*cos(x)-0.44*sin(x)**2)
	!! d2f/dx2 = exp(-0.44*x)*(2.0*cos(x)**2 - 1.76*cos(x)*sin(x) - 2.0*sin(x)**2 + 0.1936*sin(x)**2)
	!!
	function funcTestReal( x ) result( output )
		real(8), intent(in) :: x
		real(8) :: output
		
! 		output = 1.0_8*sin(1.0_8*x) &  !  1 rad/sec component
! 				+0.6_8*sin(3.0_8*x) &  !  3 rad/sec component
! 				+0.4_8*sin(5.0_8*x) &  !  5 rad/sec component
! 				+0.2_8*sin(RandomUtils_uniform([7.0_8,10.0_8])*x)  !  uniform noise

! 		output = exp(-0.44*x)*sin(x)**2.0 + 0.001*sin(30.0*x)  ! noise 30 rad/sec
		
		output = 0.5_8*cos(5.0_8*x) - 0.5_8*sin(5.0_8*x) + 2.0_8*sin(2.5_8*x);
	end function funcTestReal
	
	!>
	!! This is neccesary only for FFT_test()
	!!       f = exp(-0.44*x)*sin(x)**2
	!!   df/dx = exp(-0.44*x)*(2.0*sin(x)*cos(x)-0.44*sin(x)**2)
	!! d2f/dx2 = exp(-0.44*x)*(2.0*cos(x)**2 - 1.76*cos(x)*sin(x) - 2.0*sin(x)**2 + 0.1936*sin(x)**2)
	!!
	function dfuncTest( x ) result( output )
		real(8), intent(in) :: x
		complex(8) :: output
		
		output = exp(-0.44*x)*(2.0*sin(x)*cos(x)-0.44*sin(x)**2) + 2.0*Math_PI*30.0*0.001*cos(30.0*x)   ! noise 30 rad/sec Hz
	end function dfuncTest
	
	!>
	!! This is neccesary only for FFT_test()
	!!       f = exp(-0.44*x)*sin(x)**2
	!!   df/dx = exp(-0.44*x)*(2.0*sin(x)*cos(x)-0.44*sin(x)**2)
	!! d2f/dx2 = exp(-0.44*x)*(2.0*cos(x)**2 - 1.76*cos(x)*sin(x) - 2.0*sin(x)**2 + 0.1936*sin(x)**2)
	!!
	function d2funcTest( x ) result( output )
		real(8), intent(in) :: x
		complex(8) :: output
		
		output = exp(-0.44*x)*(2.0*cos(x)**2 - 1.76*cos(x)*sin(x) - 2.0*sin(x)**2 + 0.1936*sin(x)**2)
	end function d2funcTest
	
	!>
	!! @bief test
	!!
	subroutine FFT_test()
		type(Grid) :: xGrid
		type(CNFunction) :: funcA, dFuncA, fftFuncA, fftDFuncA
		type(CNFunction) :: funcB, dFuncB, fftFuncB, fftDFuncB
		type(CNFunction) :: funcAB, dFuncAB, fftFuncAB, fftDFuncAB
		type(RNFunction) :: spectrum
		type(FFT) :: fftF, fftB
		real(8) :: exactValue
		real(8) :: value
		integer :: i, j
		real(8), allocatable :: array(:)
		complex(8), allocatable :: cArray(:)
		
		
! 		call xGrid.init( 0.0_8, 6.0_8*Math_PI, 1000 )
! 		call xGrid.init( 0.0_8, 20.0_8*Math_PI, 1000 )
! 		call funcA.fromFunction( xGrid, funcTest )
! 		call dFuncA.fromFunction( xGrid, dfuncTest )
! 		call fftF.init( funcA )
! 		
! 		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 		! Para verificar:
! 		!   $ make && ./test > salida
! 		!   gnuplot> plot "salida" i 0 w l lw 2, "" i 1 w l, "" i 2 w l, "" i 3 w l lw 2
! 		! verde y azul deben dar igual
! 		!   gnuplot> plot [-70:70] "salida" i 4 w l
! 		! debe dar picos a 
! ! 		fftFuncA = fftF.filter( kindOfFilter=FFT_FILTER_AMPLITUDE_FRACTION, cutoff=0.01_8 )
! 		fftFuncA = fftF.filter( kindOfFilter=FFT_FILTER_FREQUENCY, cutoff=27.0_8 )
! 		spectrum = fftF.spectrum()
! ! 		fftDFuncA = fftF.derivative( 1, kindOfFilter=FFT_FILTER_AMPLITUDE_FRACTION, cutoff=0.01_8 )
! 		fftDFuncA = fftF.derivative( 1, kindOfFilter=FFT_FILTER_FREQUENCY, cutoff=27.0_8 )
		
! 		write(*,*) "#-----------------------"
! 		write(*,*) "# Function"
! 		write(*,*) "#-----------------------"
! 		call funcA.save()
! 		write(*,*)
! 		write(*,*)
! 		write(*,*) "#-----------------------"
! 		write(*,*) "# FFT Function"
! 		write(*,*) "#-----------------------"
! 		call fftFuncA.save()
! 		write(*,*)
! 		write(*,*)
! 		write(*,*) "#-----------------------"
! 		write(*,*) "# der Function"
! 		write(*,*) "#-----------------------"
! 		call dFuncA.save()
! 		write(*,*)
! 		write(*,*)
! 		write(*,*) "#-----------------------"
! 		write(*,*) "# FFT der Function"
! 		write(*,*) "#-----------------------"
! 		call fftDFuncA.save()
! 		write(*,*)
! 		write(*,*)
! 		write(*,*) "#-----------------------"
! 		write(*,*) "# Spectrum"
! 		write(*,*) "#-----------------------"
! 		call spectrum.save()
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
		
! 		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 		! Method No 1
! 		!----------------
! 		! You are interested in some of these options:
! 		!   - Get the fourier transform
! 		!   - Get the inverse fourier transform
! 		!   - Get the fourier spectrum
! 		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 		call xGrid.init( -30.0_8, 30.0_8, 60000 )
! 		call funcA.fromFunction( xGrid, funcTest )
! ! 		call funcA.fromFile( "salida.dat" )
! 		call funcA.save( "funcA-method1-orig.dat" )
! 		
! 		fftFuncA = FFT_transform( funcA, fftShift=.false. )
! 		call FFT_shift( fftFuncA )
! 		call fftFuncA.save( "funcA-method1-fft.dat" )
! 		
! 		fftFuncA = FFT_transform( funcA, fftShift=.false. )
! 		funcA = FFT_iTransform( fftFuncA, fftShift=.false. )
! 		call funcA.save( "funcA-method1-rebuild.dat" )
! 		
! 		spectrum = FFT_spectrum( funcA )
! 		
! 		call spectrum.save( "funcA-method1-spectrum.dat" )
! 		
! 		write(*,"(A)") "gnuplot> plot 'funcA-method1-orig.dat' w l ls 1, 'funcA-method1-rebuild.dat' w l ls 3"
! 		write(*,"(A)") "gnuplot> plot 'funcA-method1-fft.dat' w l ls 1, '' u 1:3 w l ls 2"
! 		write(*,"(A)") "gnuplot> plot 'funcA-method1-spectrum.dat' w l ls 1"

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		! Verificando FFT shift
		!-----------------------
		! https://github.com/numpy/numpy/blob/v1.9.1/numpy/fft/helper.py#L19
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		allocate( array(10) )
		
		write(*,*) "--------------------------"
		write(*,*) " Verifing FFT shift Array"
		write(*,*) "--------------------------"
		
		call FFT_fftfreqs( array, 0.1_8 )
		write(*,"(A30,<size(array)>F10.5)") "freq array = ", array
		call FFT_shift( array )
		write(*,"(A30,<size(array)>F10.5)") "shifted freq array = ", array
		call FFT_ishift( array )
		write(*,"(A30,<size(array)>F10.5)") "inverse shifted freq array = ", array
		
		write(*,*) "-------------------------"
		write(*,*) " Verifing FFT shift Grid"
		write(*,*) "-------------------------"
		
		call xGrid.init( array )
		write(*,"(A30,<xGrid.nPoints>F10.5)") "freq array = ", xGrid.data
		call FFT_shift( xGrid )
		write(*,"(A30,<xGrid.nPoints>F10.5)") "shifted freq array = ", xGrid.data
		call FFT_ishift( xGrid )
		write(*,"(A30,<xGrid.nPoints>F10.5)") "inverse shifted freq array = ", xGrid.data
		
		deallocate( array )
		
		write(*,*) "--------------------"
		write(*,*) " Verifing FFT Array"
		write(*,*) "--------------------"
		
		allocate( cArray(8) )
		
		do i=1,size(cArray)
			cArray(i) = exp( 2*Math_I*Math_PI*real(i-1,8)/size(cArray) )
		end do
		
		write(*,*) " FFT"
		write(*,"(A10,<2*size(cArray)>F10.5)") " input = ", cArray
		call FFT_fft( cArray )
		write(*,"(A10,<2*size(cArray)>E10.3)") "output = ", cArray
		
		deallocate( cArray )
		
		allocate( cArray(4) )
		
		cArray = [0, 4, 0, 0]
		
		write(*,*) " FFT"
		write(*,"(A10,<2*size(cArray)>F10.5)") " input = ", cArray
		call FFT_ifft( cArray )
		write(*,"(A10,<2*size(cArray)>F10.5)") "output = ", cArray
		
		deallocate( cArray )
		
		write(*,*) "-------------------------"
		write(*,*) " Verifing FFT CNFunction"
		write(*,*) "-------------------------"
		
		call xGrid.init( 0.0_8, 6.0_8*Math_PI, 1000 )
		call funcA.init( xGrid, funcTest )
		call funcA.show()
		call FFT_fft_CNFunction( funcA )
		
! 		!---------------------------------------------
! 		! Por ejemplo:
! 		!   - Calculando la derivada de una función
! 		!---------------------------------------------
! 		call funcA.fromFunction( xGrid, funcTest )
! 		
! 		fftFuncA = FFT_transform( funcA )
! 		fftDFuncA = fftFuncA*( fftFuncA.xGrid*Math_I )**1.0
! 		dFuncA = FFT_iTransform( fftDFuncA )
		
! 		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 		! Method No 2
! 		!----------------
! 		! Para ir i volver, no se debe sincronizar el grid
! 		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 		call funcA.fromFunction( xGrid, funcTest )
! 		call funcB.fromFunction( xGrid, funcTestReal )
! 		
! 		fftFuncA = FFT_calculate( funcA )
! 		fftFuncB = FFT_calculate( funcB )
! 		
! 		fftFuncAB = fftFuncA*fftFuncB
! 		
! 		funcAB = iFFT_calculate( fftFuncAB )
! 		
! 		call funcAB.save( "funcAB-method1.dat" )
! 		
! 		! ... o ... ( Ahorrandose la función fftFuncAB )
! 		
! 		call funcA.fromFunction( xGrid, Math_ubox )
! 		call funcB.fromFunction( xGrid, Math_ubox )
! 		call funcAB.fromGrid( xGrid )
! 		
! 		call fftB.init( funcAB, type=FFT_BACKWARD )
! 		
! 		funcAB = FFT_calculate( funcA )*FFT_calculate( funcB )
! 		
! 		call fftB.execute( funcAB )
! 		
! 		call funcAB.save( "funcAB-method2.dat" )
		
! 		call fftF.init( funcA, persist=.true. )
! 		call fftB.init( funcA, persist=.true. )
! 		
! 		call funcA.save()
! 		call fftF.executePersist()
! 		call funcA.save()
! 		call fftB.executePersist()
! 		call funcA.save()
		
	end subroutine FFT_test
	
end module FFT_
